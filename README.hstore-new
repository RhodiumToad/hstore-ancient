============================================================================
WARNING WARNING WARNING
============================================================================

THIS VERSION OF hstore IS NOT BINARY COMPATIBLE WITH THE ONE SHIPPED
IN contrib/hstore IN POSTGRESQL 8.3 and 8.4. IF YOU ALREADY HAVE DATA
IN YOUR DATABASE THAT USES THE hstore TYPE, THEN YOU MUST FOLLOW THE
PROCEDURES GIVEN BELOW TO INSTALL THIS VERSION OTHERWISE YOU WILL
SUFFER CRASHES AND POTENTIALLY LOST DATA.

ALWAYS MAKE BACKUPS BEFORE ATTEMPTING TO INSTALL THIS.

============================================================================

hstore-new
==========

This module is an enhanced version of the hstore type from
contrib/hstore, intended to allow the new features to be used in
existing postgresql versions. (This code is being submitted for
inclusion in future versions, but I have had requests to backport the
functionality.)

This code supports all the functions provided by contrib/hstore and
adds the following additions:

  - removal of undocumented 65535-byte limit on keys/values; both
    keys and values can now be as long as desired, within the 1GB
    limit for the whole hstore value (though you'll find a lot of
    stuff breaks if you have hstores over 500MB, so don't try).

  - support for btree and hash opclasses (allows hstores to be
    compared for equality, aggregated, and have UNIQUE indexes)

  - binary I/O now supported

  - many new functions and operators:

    hstore -> text[]  returns text[]   (slice to value array)
    hstore => text[]  returns hstore   (slice to new hstore)
    hstore ?| text[]  returns boolean  (check for any of a list of keys)
    hstore ?& text[]  returns boolean  (check for all of a list of keys)
    hstore - text     returns hstore   (delete one element)
    hstore - text[]   returns hstore   (delete many elements)
    hstore - hstore   returns hstore   (delete matching pairs)
    text[] => text[]  returns hstore   (construct from key/value arrays)
    hstore = hstore   returns boolean  (equality)
    hstore <> hstore  returns boolean  (inequality)
    record #= hstore  returns record   (see populate_record)

  - conversions between hstore and record values:

    hstore(record)    - construct an hstore from a record
    populate_record(record,hstore)
        - fill in fields of a record as specified by an hstore


INSTALLATION
============

Compile and install the module as follows (ensuring that the pg_config
program for the installed server version is on your PATH):

    gmake install

Note that this installs the module under the name "hstore-new.so" to
avoid overwriting any previous hstore.so module. This step is safe to
perform even if you have existing hstore data.

If the old hstore type is not installed, you can simply install the
new one in the normal way, e.g.:

   psql -f "$(pg_config --sharedir)/contrib/hstore-new.sql" dbname

or using \i from inside psql. Do _NOT_ attempt to use psql -1, the
script contains its own BEGIN/COMMIT.

(If the old hstore type is installed, but you have NO stored data that
uses it (i.e. no table columns of hstore type), then you can deinstall
the old type before installing the new one; it will be necessary to
recreate any functions that used hstore as a parameter or result type,
but otherwise the types are functionally compatible.)

It is safe to use the old and new hstore types in different databases
in the same cluster.

It is possible (though not recommended, other than for migration as
detailed below) to install both the old and the new types in the
_same_ database by placing them in different schemas. Note that this
can be very confusing!


CONVERSION OF EXISTING DATA
===========================

If you already have the old hstore type installed, and you wish to
replace it completely with the new type, preserving data, then the
following procedure is believed to work.

** ALWAYS MAKE BACKUPS BEFORE PROCEEDING FURTHER **

We will assume that the old type was installed in the "public"
schema and that the new type is also to be installed there.
(A variation would be to install the new type in its own schema,
but that complicates the handling of search_path in future.)

We will also assume that this conversion is happening during a
maintenance window, so we don't have to worry about concurrent
access. (It _is_ possible to work around this, but if you're
enough of an expert to handle that, you should be able to work
out the details yourself.)

This can be done in a single transaction in psql; if you attempt
this, I strongly recommend \set ON_ERROR_ROLLBACK 'on' so that
typos don't kill the entire transaction. Copying the commands
into a script may be preferable, or using the functions described
below.

First, we need some utility definitions:

  CREATE LANGUAGE plpgsql;  -- in the unlikely event you don't have it already
  CREATE FUNCTION exec(text) RETURNS void LANGUAGE plpgsql
    AS $f$ begin execute $1; end; $f$;

Next, we move aside critical functions from the original version:

  BEGIN;   -- if we're doing it as one transaction
  CREATE SCHEMA hstore_tmp;
  -- types can't be renamed but can be moved:
  ALTER TYPE public.hstore SET SCHEMA hstore_tmp;
  ALTER TYPE public.ghstore SET SCHEMA hstore_tmp;
  -- operator classes can't be moved between schemas
  ALTER OPERATOR CLASS gist_hstore_ops USING gist
    RENAME TO gist_hstore_ops_old;
  ALTER OPERATOR CLASS gin_hstore_ops USING gin
    RENAME to gin_hstore_ops_old;
  -- operators can't be renamed or moved
  DROP OPERATOR public.=>(text,text);
  CREATE OPERATOR hstore_tmp.=> ( LEFTARG = text,
    RIGHTARG = text, PROCEDURE = hstore_tmp.tconvert );
  -- move conflicting functions
  ALTER FUNCTION hstore_in(cstring) SET SCHEMA hstore_tmp;
  ALTER FUNCTION ghstore_in(cstring) SET SCHEMA hstore_tmp;
  ALTER FUNCTION tconvert(text,text) SET SCHEMA hstore_tmp;
  SELECT exec('ALTER FUNCTION ' || amproc::regprocedure
              || ' SET SCHEMA hstore_tmp')
    FROM pg_amproc
   WHERE amproclefttype='hstore_tmp.hstore'::regtype
     AND amproc::regproc::text like '%hstore%';
  
  

